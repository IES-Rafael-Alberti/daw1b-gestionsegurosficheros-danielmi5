## **Gu√≠a de Implementaci√≥n Paso a Paso**

1. **Crea los paquetes** (`model`, `data`, `service`, `ui`, `utils`).
2. **Implementa los interfaces, clases y enumeraciones en `model`**.
3. **Desarrolla los repositorios en `data`**, diferenciando memoria y ficheros.
4. **Crea los servicios en `service`**, aplicando inyecci√≥n de dependencias.
5. **Dise√±a la UI en `ui`** con una implementaci√≥n en consola.
6. **Gestiona los ficheros en `utils`** y usa la interfaz definida para mantener el c√≥digo desacoplado.
7. **Implementa el `Main.kt`** para iniciar el programa, gestionar el men√∫ y las dependencias.

***NOTA (20/03/2025 20:15)*** - Por ahora os dejo explicados y guiados casi al 100% los apartados 1, 2 y 6, a menos que se me ocurra algo m√°s o vea alg√∫n problema que debemos solucionar.
Cuando tenga otro rato, terminar√© mi versi√≥n y os subir√© el resto de apartados, actualizando esta informaci√≥n.

---

Aqu√≠ ten√©is un desglose del proyecto con **indicaciones detalladas** sobre qu√© debe hacer cada paquete y c√≥mo implementar cada clase.

### **1. Estructura del Proyecto (paquetes)**  
Deb√©is crear los siguientes paquetes:

- **üìÇ `app`** ‚Üí Contendr√° las clases encargadas de gestionar el flujo principal de la aplicaci√≥n, como el men√∫ y la navegaci√≥n entre opciones.  
- **üìÇ `data`** ‚Üí Maneja la persistencia de datos, con repositorios que almacenan informaci√≥n en memoria o en ficheros.  
- **üìÇ `model`** ‚Üí Define la estructura de los datos, incluyendo clases, enumeraciones y estructuras necesarias para representar la informaci√≥n del sistema.  
- **üìÇ `service`** ‚Üí Contiene la l√≥gica de negocio, implementando la gesti√≥n de seguros y usuarios mediante la interacci√≥n con los repositorios.  
- **üìÇ `ui`** ‚Üí Se encarga de la interacci√≥n con el usuario, implementando la interfaz en consola o cualquier otro medio de entrada/salida.  
- **üìÇ `utils`** ‚Üí Agrupa herramientas y utilidades auxiliares, como gesti√≥n de ficheros y encriptaci√≥n.  

**Con esta organizaci√≥n, el c√≥digo ser√° m√°s modular, mantenible y escalable.**
   
### **2. `model` (Modelo de Datos)**
Este paquete contiene **todas las clases y enumeraciones** que definen los datos que maneja la aplicaci√≥n.

#### **ENUMERACIONES**

##### **`Perfil`**: Define los roles de usuario.
  
   - Valores: `ADMIN, GESTION, CONSULTA`
  
      * `ADMIN`: Puede gestionar usuarios y seguros.
      * `GESTION`: Puede gestionar seguros, pero no crear/eliminar usuarios.
      * `CONSULTA`: Solo puede ver informaci√≥n.

   - M√©todos est√°ticos: `getPerfil(valor: String): Cobertura` *(Retorna el valor de la enumeraci√≥n correspondiente a la cadena de caracteres que se pasa por argumento o CONSULTA si no existe. Por ejemplo: getPerfil("gestion") retornar√≠a GESTION)*

##### **`Cobertura`**: Indica el tipo de cobertura de los seguros de autom√≥vil.
    
   - Valores: `TERCEROS, TERCEROS_AMPLIADO, FRANQUICIA_200, FRANQUICIA_300, FRANQUICIA_400, FRANQUICIA_500, TODO_RIESGO`  

   - Propiedades: `desc` *(Terceros, Terceros +, Todo Riesgo con Franquicia de 200‚Ç¨, ... , Todo Riesgo)*

   - M√©todos est√°ticos: `getCobertura(valor: String): Cobertura` *(Retorna el valor de la enumeraci√≥n correspondiente a la cadena de caracteres que se pasa por argumento o TERCEROS si no existe. Por ejemplo: getCobertura("terceros_ampliado") retornar√≠a TERCEROS_AMPLIADO)*

##### **`Auto`**: Tipo de autom√≥vil asegurado.

   - Valores: `COCHE, MOTO, CAMION`

   - M√©todos est√°ticos: `getAuto(valor: String): Auto` *(Retorna el valor de la enumeraci√≥n correspondiente a la cadena de caracteres que se pasa por argumento o COCHE si no existe. Por ejemplo: getAuto("moto") retornar√≠a MOTO)*

##### **`Riesgo`**: Define los niveles de riesgo en los seguros de vida.

   - Valores: `BAJO, MEDIO, ALTO`

   - Propiedades: `interesAplicado` *(2.0, 5.0, 10.0)*.

   - M√©todos est√°ticos: `getRiesgo(valor: String): Riesgo` *(Retorna el valor de la enumeraci√≥n correspondiente a la cadena de caracteres que se pasa por argumento o MEDIO si no existe. Por ejemplo: getRiesgo("bajo") retornar√≠a BAJO)*

#### **INTERFACES**

##### **`IExportable`**

- Contiene un √∫nico m√©todo `serializar(): String`

#### **CLASES**

##### **`Usuario`**

- Debe implementar un contrato como una clase de tipo `IExportable`.

- **Atributos:** `nombre`, `clave` y `perfil`. El nombre de usuario debe ser √∫nico.

- **Propiedades y m√©todos est√°cticos:**
  - `crearUsuario(datos: List<String>): Usuario`: Retorna una instancia de `Usuario`. El par√°metro que recibe, `datos`, contiene el valor de cada propiedad en orden y deben ser convertidos seg√∫n el tipo de la propiedad si es necesario. Muy atentos a controlar su llamada para evitar EXCEPCIONES por conversiones err√≥neas *(aunque si almacenamos bien la info no deber√≠a ocurir, pero un buen programador/a lo controla SIEMPRE)*

- **M√©todos:**
  - `verificarClave(claveEncriptada: String): Boolean`: Retorna si la clave es la misma que la almacenada en el usuario.
  - `cambiarClave(nuevaClaveEncriptada: String)`: Actualiza la clave del usuario *(este m√©todo va a actualizar la clave del usuario directamente, pero en el servicio que gestiona los usuarios debe solicitar la antigua clave, verificarla y pedir la nueva)*.

- **M√©todos que sobreescribe:**
  - `serializar(): String`: Retornar una cadena de caracteres con los valores de los atributos de la clase separados por `;`.

##### **`Seguro`**

- Representa cualquier tipo de seguro. Ser√° la clase base de `SeguroHogar`, `SeguroAuto` y `SeguroVida`.

- Debe implementar un contrato como una clase de tipo `IExportable`.

- **Atributos:** `numPoliza` *(√∫nica por seguro)*, `dniTitular`, `importe`. Los dos primeros no ser√°n accesibles desde fuera de la clase y el √∫ltimo solo ser√° accesible desde la clase y las clases que la extiendan.

- **M√©todos abstractos:**
  - `calcularImporteAnioSiguiente(interes: Double): Double`
  - `tipoSeguro(): String`

- **M√©todos:**
  - `comprobarNumPoliza(numPoliza: Int): Boolean`: Retorna `true/false` indicando si el par√°metro que hemos pasado como argumento al m√©todo es igual o no al atributo `numPoliza` de la instancia.

- **M√©todos que sobreescribe:**
  - `serializar(): String`: Retornar una cadena de caracteres con los valores de los atributos de la clase separados por `;` *(por ejemplo: "100001;44027777K;327.40")*
  - `toString(): String`: Retornar la informaci√≥n del seguro con el siguiente formato *"Seguro(numPoliza=100001, dniTitular=44027777K, importe=327.40)"*. El `importe`siempre con dos posiciones decimales.
  - `hashCode(): Int`: C√≥mo `numPoliza`ser√° √∫nico por cada seguro, retornar el valor de hashCode de un seguro en base solo a la dicha propiedad *(sin utilizar ning√∫n n√∫mero primo, ni m√°s propiedades)*.
  - `equals(other: Any?): Boolean`: Utilizad igual que en el anterior m√©todo, solo la propiedad `numPoliza` para su comparaci√≥n *(por supuesto, hacedlo bien, antes deb√©is realizar la comparaci√≥n por referencia y verificar tambi√©n si se trata de un `Seguro`)*

##### **CLASES QUE HEREDAN DE `Seguro`**

##### **`SeguroHogar`**

- **Atributos espec√≠ficos:** `metrosCuadrados`, `valorContenido`, `direccion`, `anioConstruccion`. No ser√°n accesibles desde fuera de la clase.

- **Constructores:** Esta clase no implementa un constructor primaro. En su lugar, tiene dos constructores secundarios, los cuales llaman al constructor de la **clase padre `Seguro`** con `super(...)`.
  - Primer constructor secundario: Lo usaremos en la Contratac√≠on de un **NUEVO** seguro *(genera un n√∫mero de p√≥liza autom√°ticamente, gracias a una propiedad privada numPolizasAuto que comienza en el n√∫mero 100000)*
  - Segundo constructor secundario: Lo usaremos para crear una p√≥liza ya existente *(es decir, cuando recuperamos los seguros desde la persistencia de datos)*. Este segundo constructor no se podr√° llamar desde fuera de la clase.

- **Propiedades y m√©todos est√°cticos:**
  - `numPolizasAuto: Int`: Nos ayuda a generar `numPoliza` de los nuevos seguros. No ser√° accesible desde fuera de la clase.
  - `crearSeguro(datos: List<String>): SeguroHogar`: Retorna una instancia de `SeguroHogar`. El par√°metro que recibe, `datos`, contiene el valor de cada propiedad en orden y deben ser convertidos seg√∫n el tipo de la propiedad si es necesario. Muy atentos a controlar su llamada para evitar EXCEPCIONES por conversiones err√≥neas *(aunque si almacenamos bien la info no deber√≠a ocurir, pero un buen programador/a lo controla SIEMPRE)*

- **M√©todos que sobreescribe:**
  - `calcularImporteAnioSiguiente()`: Retornar el importe del a√±o siguiente bas√°ndose en el inter√©s que se pasa por par√°metro, sum√°ndole un inter√©s residual de 0.02% por cada 5 a√±os de antiguedad del hogar *(Ej: 4.77 a√±os de antiguedad no incrementa, pero 23,07 sumar√° al inter√©s el valor de 4 x 0.02 = 0.08)*.
  - `tipoSeguro(): String`: Retornar el nombre de la clase usando `this::class.simpleName` y el operador elvis para indicar al compilador que si `simpleName` es `null` *(cosa que nunca debe pasar, ya que la clase tiene un nombre)*, entonces deber√° retornar el valor "Desconocido".
  - `serializar(): String`: Modificar el comportamiento de este m√©todo heredado, para retornar una cadena de caracteres con los valores de los atributos de la clase separados por `;`.
  - `toString(): String`: Retornar la informaci√≥n del seguro de hogar con el siguiente formato *"Seguro Hogar(numPoliza=100001, dniTitular=44027777K, importe=327.40, ...)"*. ¬øC√≥mo lo pod√©is hacer si no ten√©is accesible los atributos de la clase base `numPoliza` y `dniTitular`?

##### **`SeguroAuto`**

- **Atributos espec√≠ficos:** `descripcion`, `combustible`, `tipoAuto`, `cobertura`, `asistenciaCarretera`, `numPartes`. No ser√°n accesibles desde fuera de la clase.

- **Constructores:** Esta clase no implementa un constructor primaro. En su lugar, tiene dos constructores secundarios, los cuales llaman al constructor de la **clase padre `Seguro`** con `super(...)`.
  - Primer constructor secundario: Lo usaremos en la Contratac√≠on de un **NUEVO** seguro *(genera un n√∫mero de p√≥liza autom√°ticamente, gracias a una propiedad privada numPolizasAuto que comienza en el n√∫mero 400000)*
  - Segundo constructor secundario: Lo usaremos para crear una p√≥liza ya existente. Este segundo constructor no se podr√° llamar desde fuera de la clase.

- **Propiedades y m√©todos est√°cticos:**
  - `numPolizasAuto: Int`: Nos ayuda a generar `numPoliza` de los nuevos seguros. No ser√° accesible desde fuera de la clase.
  - `crearSeguro(datos: List<String>): SeguroAuto`: Retorna una instancia de `SeguroAuto`. El par√°metro que recibe, `datos`, contiene el valor de cada propiedad en orden y deben ser convertidos seg√∫n el tipo de la propiedad si es necesario.

- **M√©todos que sobreescribe:**
  - `calcularImporteAnioSiguiente()`: Retornar el importe del a√±o siguiente bas√°ndose en el inter√©s que se pasa por par√°metro, sum√°ndole un inter√©s residual del 2% por cada parte declarado.
  - `tipoSeguro(): String`: Retornar el nombre de la clase usando `this::class.simpleName` y el operador elvis para indicar al compilador que si `simpleName` es `null`, entonces deber√° retornar el valor "Desconocido".
  - `serializar(): String`: Modificar el comportamiento de este m√©todo heredado, para retornar una cadena de caracteres con los valores de los atributos de la clase separados por `;`.
  - `toString(): String`: Retornar la informaci√≥n del seguro de auto con un formato similar al del seguro de hogar.

##### **`SeguroVida`**

- **Atributos espec√≠ficos:** `fechaNac`, `nivelRiesgo`, `indemnizacion`. Usad el tipo de datos `LocalDate` para `fechaNac`. No ser√°n accesibles desde fuera de la clase.

- **Constructores:** Esta clase no implementa un constructor primaro. En su lugar, tiene dos constructores secundarios, los cuales llaman al constructor de la **clase padre `Seguro`** con `super(...)`.
  - Primer constructor secundario: Lo usaremos en la Contratac√≠on de un **NUEVO** seguro *(genera un n√∫mero de p√≥liza autom√°ticamente, gracias a una propiedad privada numPolizasAuto que comienza en el n√∫mero 800000)*
  - Segundo constructor secundario: Lo usaremos para crear una p√≥liza ya existente. Este segundo constructor no se podr√° llamar desde fuera de la clase.

- **Propiedades y m√©todos est√°cticos:**
  - `numPolizasAuto: Int`: Nos ayuda a generar `numPoliza` de los nuevos seguros. No ser√° accesible desde fuera de la clase.
  - `crearSeguro(datos: List<String>): SeguroVida`: Retorna una instancia de `SeguroVida`. El par√°metro que recibe, `datos`, contiene el valor de cada propiedad en orden y deben ser convertidos seg√∫n el tipo de la propiedad si es necesario.

- **M√©todos que sobreescribe:**
  - `calcularImporteAnioSiguiente()`: Retornar el importe del a√±o siguiente bas√°ndose en el inter√©s que se pasa por par√°metro, sum√°ndole un inter√©s residual del 0.05% por cada a√±o cumplido y el inter√©s de su nivel de riesgo *(Ver clase enumerada `Riesgo`)*.
  - `tipoSeguro(): String`: Retornar el nombre de la clase usando `this::class.simpleName` y el operador elvis para indicar al compilador que si `simpleName` es `null`, entonces deber√° retornar el valor "Desconocido".
  - `serializar(): String`: Modificar el comportamiento de este m√©todo heredado, para retornar una cadena de caracteres con los valores de los atributos de la clase separados por `;`.
  - `toString(): String`: Retornar la informaci√≥n del seguro de auto con un formato similar al del seguro de hogar.

---

### **3. `data` (Repositorios y Persistencia)**

#### **Interfaces:**

```
interface IRepoSeguros {
    fun agregar(seguro: Seguro): Boolean
    fun buscar(numPoliza: Int): Seguro?
    fun eliminar(seguro: Seguro): Boolean
    fun eliminar(numPoliza: Int): Boolean
    fun obtenerTodos(): List<Seguro>
    fun obtener(tipoSeguro: String): List<Seguro>
}
```

```kotlin
interface IRepoUsuarios {
}
```

#### **Clases:**

##### **RepoSegurosMem:**

##### **RepoSegurosFich:**

##### **RepoUsuariosMem:**

##### **RepoUsuariosFich:**


---

### **4. `service` (L√≥gica de Negocio)**
Aqu√≠ se implementan las **operaciones principales** que la interfaz de usuario ejecutar√°.

#### **Interfaces (`IServUsuarios`, `IServSeguros`)**

```kotlin
interface IServSeguros {
}
```

```kotlin
interface IServUsuarios {
}
```

#### **Servicios (`GestorUsuarios`, `GestorSeguros`)**
- Implementan las interfaces y usan los repositorios.
- `GestorUsuarios` maneja la autenticaci√≥n, creaci√≥n de nuevos usuarios y cambios de contrase√±a.
- `GestorSeguros` se encarga de contratar, listar y eliminar seguros.

##### **GestorUsuarios:**

##### **GestorSeguros:**

---

### **5. `ui` (Interfaz de Usuario)**
Este paquete maneja **c√≥mo interact√∫a el usuario** con el sistema.

#### **Interfaz `IUserInterface`**
- Define m√©todos como `mostrar(mensaje: String)`, etc.

#### **`Consola`** (Implementaci√≥n de `IUserInterface`)
- Imprime mensajes en la terminal y recibe entradas del usuario.

---

### **6. `utils` (Utilidades)**
Contiene herramientas para operaciones repetitivas.

#### **Interfaz `IUtilFicheros`**
- Define m√©todos de lectura y escritura en archivos.

```kotlin
interface IUtilFicheros {
    fun leerArchivo(ruta: String): List<String>
    fun leerSeguros(ruta: String, mapaSeguros: Map<String, (List<String>) -> Seguro>): List<Seguro>
    fun agregarLinea(ruta: String, linea: String): Boolean
    fun <T: IExportable> escribirArchivo(ruta: String, elementos: List<T>): Boolean
    fun existeFichero(ruta: String): Boolean
    fun existeDirectorio(ruta: String): Boolean
}
```

#### **Clase `Ficheros`**
- Implementa `IUtilFicheros` y maneja el acceso a los `.txt`.

#### **Interfaz `IUtilSeguridad`**
- Define m√©todos para encriptar y verificar claves.

```kotlin
interface IUtilSeguridad {
    fun encriptarClave(clave: String, nivelSeguridad: Int = 12): String
    fun verificarClave(claveIngresada: String, hashAlmacenado: String): Boolean
}
```

#### **Clase `Seguridad`

- Incluir la implementaci√≥n de la librer√≠a externa BCrypt en el fichero `build.gradle`:

```kotlin
dependencies {
    testImplementation(kotlin("test"))
    implementation("at.favre.lib:bcrypt:0.9.0")
}
```

- Contenido de la clase `Seguridad`:

```kotlin
import at.favre.lib.crypto.bcrypt.BCrypt

class Seguridad : IUtilSeguridad {

    /**
     * Genera un hash seguro de la clave utilizando el algoritmo BCrypt.
     *
     * BCrypt es un algoritmo de hashing adaptativo que permite configurar un nivel de seguridad (coste computacional),
     * lo que lo hace ideal para almacenar contrase√±as de forma segura.
     *
     * @param clave La contrase√±a en texto plano que se va a encriptar.
     * @param nivelSeguridad El factor de coste utilizado en el algoritmo BCrypt. Valores m√°s altos aumentan la seguridad
     * pero tambi√©n el tiempo de procesamiento. El valor predeterminado es `12`, que se considera seguro para la mayor√≠a
     * de los casos.
     * @return El hash de la clave en formato String, que puede ser almacenado de forma segura.
     */
    override fun encriptarClave(clave: String, nivelSeguridad: Int = 12): String {
        return BCrypt.withDefaults().hashToString(nivelSeguridad, clave.toCharArray())
    }

    /**
     * Verifica si una contrase√±a ingresada coincide con un hash almacenado previamente usando BCrypt.
     *
     * Esta funci√≥n permite autenticar a un usuario comprobando si la clave ingresada,
     * tras ser procesada con BCrypt, coincide con el hash almacenado en la base de datos.
     *
     * @param claveIngresada La contrase√±a en texto plano que se desea comprobar.
     * @param hashAlmacenado El hash BCrypt previamente generado contra el que se verificar√° la clave ingresada.
     * @return `true` si la clave ingresada coincide con el hash almacenado, `false` en caso contrario.
     */
    override fun verificarClave(claveIngresada: String, hashAlmacenado: String): Boolean {
        return BCrypt.verifyer().verify(claveIngresada.toCharArray(), hashAlmacenado).verified
    }

}
```

---

### **7. `Main.kt` (Punto de Entrada)**
- Inicializa repositorios y servicios.
- Pide credenciales o permite crear un `ADMIN` si no hay usuarios.
- Carga el **men√∫ principal** para gestionar usuarios y seguros.



